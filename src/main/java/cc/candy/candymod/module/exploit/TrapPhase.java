package cc.candy.candymod.module.exploit;

import cc.candy.candymod.module.Module;
import cc.candy.candymod.setting.Setting;
import cc.candy.candymod.utils.BlockUtil;
import cc.candy.candymod.utils.InventoryUtil;
import cc.candy.candymod.utils.PlayerUtil;
import net.minecraft.block.BlockTrapDoor;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

public class TrapPhase extends Module {
    public Setting<Float> offset = register(new Setting("Offset" , 0.6F , 1.0F , 0.0F));
    public Setting<Boolean> silentSwitch = register(new Setting("SilentSwitch" , true));
    public Setting<Boolean> packetPlace = register(new Setting("PacketPlace" , true));

    public TrapPhase(){
        super("TrapPhase" , Categories.EXPLOIT , false , false);
    }

    public void onTick(){
        if(nullCheck()) return;
        int slot = InventoryUtil.findHotbarBlockWithClass(BlockTrapDoor.class);
        if(slot == -1){
            sendMessage("Cannot find TrapDoor! disabling");
            disable();
            return;
        }

        BlockPos playerPos = PlayerUtil.getPlayerPos();
        BlockPos trappos = null;
        BlockPos[] offsets = new BlockPos[]{
                new BlockPos(1 , 0 , 0) ,
                new BlockPos(-1 , 0 , 0) ,
                new BlockPos(0 , 0 ,1) ,
                new BlockPos(0 , 0 , -1)
        };
        for(BlockPos offset : offsets){
            BlockPos pos = playerPos.add(offset);
            if(!entityCheck(pos)) continue;
            if(BlockUtil.getBlock(pos).equals(Blocks.AIR) && BlockUtil.canRightClickForPlace(pos)) continue;
            trappos = pos;
        }
        if(trappos == null) {
            sendMessage("Cannot find space! disabling");
            disable();
            return;
        }

        setItem(slot);
        double x = mc.player.posX;
        double y = mc.player.posY;
        double z = mc.player.posZ;
        mc.player.connection.sendPacket(new CPacketPlayer.Position(x , y + this.offset.getValue() , z , mc.player.onGround));
        EnumFacing facing = null;
        for(EnumFacing f : EnumFacing.values()) if(trappos.add(f.getDirectionVec()).equals(playerPos)) facing = f;
        BlockUtil.rightClickBlock(trappos , facing , new Vec3d(0.5 , 0.8 , 0.5) , packetPlace.getValue());
        mc.player.connection.sendPacket(new CPacketPlayer.Position(x , y , z , mc.player.onGround));
        restoreItem();
        disable();
    }

    public boolean entityCheck(BlockPos pos){
        return mc.world.getEntitiesWithinAABB(Entity.class , new AxisAlignedBB(pos) , e -> e instanceof EntityEnderCrystal || e instanceof EntityPlayer).isEmpty();
    }

    private EnumHand oldhand = null;
    private int oldslot = -1;

    public void setItem(int slot)
    {
        if(silentSwitch.getValue()) {
            oldhand = null;
            if(mc.player.isHandActive()) oldhand = mc.player.getActiveHand();
            oldslot = mc.player.inventory.currentItem;
            mc.player.connection.sendPacket(new CPacketHeldItemChange(slot));
        }
        else {
            mc.player.inventory.currentItem = slot;
            mc.playerController.updateController();
        }
    }
    public void restoreItem()
    {
        if(oldslot != -1 && silentSwitch.getValue())
        {
            if(oldhand != null) mc.player.setActiveHand(oldhand);
            mc.player.connection.sendPacket(new CPacketHeldItemChange(oldslot));
            oldslot = -1;
            oldhand = null;
        }
    }
}
